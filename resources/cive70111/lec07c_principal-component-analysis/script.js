const defaults={correlation:0,noise:.2,count:160,meanX:0,meanY:0},state={...defaults,randomBase:[]};let currentPoints=[],currentAnalysis=null,scatterChart=null,pc1Chart=null,pc2Chart=null,hoveredPointIndex=null;const correlationControl=document.getElementById("correlation-control"),noiseControl=document.getElementById("noise-control"),countControl=document.getElementById("count-control"),meanXInput=document.getElementById("mean-x"),meanYInput=document.getElementById("mean-y"),correlationValue=document.getElementById("correlation-value"),noiseValue=document.getElementById("noise-value"),countValue=document.getElementById("count-value"),statCount=document.getElementById("stat-count"),statCorr=document.getElementById("stat-corr"),statMean=document.getElementById("stat-mean"),pc1Variance=document.getElementById("pc1-variance"),pc2Variance=document.getElementById("pc2-variance"),varianceSummary=document.getElementById("variance-summary"),covXX=document.getElementById("cov-xx"),covXY=document.getElementById("cov-xy"),covYX=document.getElementById("cov-yx"),covYY=document.getElementById("cov-yy"),resetButton=document.getElementById("reset-controls"),regenerateButton=document.getElementById("regenerate-data");function gaussianRandom(){let u=0,v=0;for(;0===u;)u=Math.random();for(;0===v;)v=Math.random();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}function createRandomSeed(){return{g1:gaussianRandom(),g2:gaussianRandom(),g3:gaussianRandom(),g4:gaussianRandom()}}function ensureRandomBase(size){for(;state.randomBase.length<size;)state.randomBase.push(createRandomSeed())}function rebuildRandomBase(){state.randomBase=[],ensureRandomBase(state.count)}function generatePoints(){ensureRandomBase(state.count);const points=[],rho=Math.max(-.999,Math.min(.999,state.correlation)),rhoTerm=Math.sqrt(Math.max(0,1-rho*rho));for(let i=0;i<state.count;i+=1){const seed=state.randomBase[i],xBase=seed.g1,yBase=rho*seed.g1+rhoTerm*seed.g2,noisyX=xBase+state.noise*seed.g3,noisyY=yBase+state.noise*seed.g4;points.push({x:noisyX+state.meanX,y:noisyY+state.meanY})}return points}function computeMean(points){const totals=points.reduce((acc,point)=>(acc.x+=point.x,acc.y+=point.y,acc),{x:0,y:0});return{x:totals.x/points.length,y:totals.y/points.length}}function computeCovariance(points,mean){let sumXX=0,sumYY=0,sumXY=0;points.forEach(point=>{const dx=point.x-mean.x,dy=point.y-mean.y;sumXX+=dx*dx,sumYY+=dy*dy,sumXY+=dx*dy});const denom=Math.max(1,points.length-1);return{xx:sumXX/denom,yy:sumYY/denom,xy:sumXY/denom}}function computeEigenvaluesAndVectors(cov){const trace=cov.xx+cov.yy,determinant=cov.xx*cov.yy-cov.xy*cov.xy,discriminant=Math.max(0,trace*trace-4*determinant),root=Math.sqrt(discriminant);let lambda1=(trace+root)/2,lambda2=(trace-root)/2;lambda1<lambda2&&([lambda1,lambda2]=[lambda2,lambda1]);if(Math.abs(cov.xy)<1e-6&&Math.abs(cov.xx-cov.yy)<1e-6)return{eigenvalues:[Math.max(lambda1,0),Math.max(lambda2,0)],eigenvectors:[[1,0],[0,1]]};const vectorFor=lambda=>{const vx=cov.xy,vy=lambda-cov.xx;if(Math.abs(vx)<1e-6&&Math.abs(vy)<1e-6)return lambda>=cov.xx?[1,0]:[0,1];const length=Math.hypot(vx,vy)||1;return[vx/length,vy/length]},pc1=vectorFor(lambda1);let pc2=vectorFor(lambda2);return Math.abs(pc1[0]*pc2[0]+pc1[1]*pc2[1])>.99&&(pc2=[-pc1[1],pc1[0]]),{eigenvalues:[Math.max(lambda1,0),Math.max(lambda2,0)],eigenvectors:[pc1,pc2]}}function computeBounds(points){let minX=1/0,maxX=-1/0,minY=1/0,maxY=-1/0;points.forEach(point=>{minX=Math.min(minX,point.x),maxX=Math.max(maxX,point.x),minY=Math.min(minY,point.y),maxY=Math.max(maxY,point.y)});const paddingX=.2*(maxX-minX||1),paddingY=.2*(maxY-minY||1);return{x:{min:minX-paddingX,max:maxX+paddingX},y:{min:minY-paddingY,max:maxY+paddingY}}}function projectOntoAxis(point,mean,axis){const deltaX=point.x-mean.x,deltaY=point.y-mean.y;return deltaX*axis[0]+deltaY*axis[1]}function formatPercent(value){return`${(100*value).toFixed(1)}%`}function analyzePoints(points){if(!points.length)return null;const mean=computeMean(points),covariance=computeCovariance(points,mean),{eigenvalues:eigenvalues,eigenvectors:eigenvectors}=computeEigenvaluesAndVectors(covariance),bounds=computeBounds(points),totalVariance=eigenvalues[0]+eigenvalues[1]||1,ratios=eigenvalues.map(value=>value/totalVariance),correlationDenom=Math.sqrt(covariance.xx*covariance.yy)||1,sampleCorr=covariance.xy/correlationDenom;return{mean:mean,covariance:covariance,eigenvalues:eigenvalues,eigenvectors:eigenvectors,bounds:bounds,varianceRatios:ratios,sampleCorr:sampleCorr?Math.max(-1,Math.min(1,sampleCorr)):0}}function buildComponentLines(analysis){if(!analysis)return{pc1:[],pc2:[]};const lengthScale=.35*Math.max(analysis.bounds.x.max-analysis.bounds.x.min,analysis.bounds.y.max-analysis.bounds.y.min,1),lines={pc1:[],pc2:[]};return analysis.eigenvectors.forEach((vector,index)=>{const ratio=analysis.varianceRatios[index]||0,length=lengthScale*(ratio+.15),dx=vector[0]*length,dy=vector[1]*length,line=[{x:analysis.mean.x-dx,y:analysis.mean.y-dy},{x:analysis.mean.x+dx,y:analysis.mean.y+dy}];0===index?lines.pc1=line:lines.pc2=line}),lines}function computeProjections(points,mean,axis){return points.map(point=>projectOntoAxis(point,mean,axis))}const highlightPlugin={id:"highlightPlugin",afterDatasetsDraw(chart){if(null===hoveredPointIndex)return;const ctx=chart.ctx,chartType=chart.canvas.id;let pointData=null;if("pca-plot"===chartType?pointData=chart.data.datasets[0].data[hoveredPointIndex]:"pc1-projection"!==chartType&&"pc2-projection"!==chartType||(pointData=chart.data.datasets[0].data[hoveredPointIndex]),!pointData)return;const xScale=chart.scales.x,yScale=chart.scales.y,x=xScale.getPixelForValue(pointData.x),y=yScale.getPixelForValue(pointData.y);ctx.save(),ctx.strokeStyle="#ff0000",ctx.lineWidth=3,ctx.fillStyle="rgba(255, 0, 0, 0.3)",ctx.beginPath(),ctx.arc(x,y,8,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.restore()}};function updateProjectionPlots(){if(!currentAnalysis||!currentPoints.length)return;const pc1Projections=computeProjections(currentPoints,currentAnalysis.mean,currentAnalysis.eigenvectors[0]),pc2Projections=computeProjections(currentPoints,currentAnalysis.mean,currentAnalysis.eigenvectors[1]),minProj1=Math.min(...pc1Projections),maxProj1=Math.max(...pc1Projections),minProj2=Math.min(...pc2Projections),maxProj2=Math.max(...pc2Projections),padding1=.1*(maxProj1-minProj1)||1,padding2=.1*(maxProj2-minProj2)||1,pc1Data=pc1Projections.map(value=>({x:value,y:.5})),pc2Data=pc2Projections.map(value=>({x:value,y:.5})),commonOptions={animation:!1,responsive:!0,maintainAspectRatio:!1,plugins:{legend:{display:!1},tooltip:{callbacks:{label:context=>`Value: ${context.parsed.x.toFixed(2)}`}}},scales:{y:{display:!1,min:0,max:1}},onHover:(event,activeElements)=>{if(activeElements.length>0){const newIndex=activeElements[0].index;hoveredPointIndex!==newIndex&&(hoveredPointIndex=newIndex,updateAllCharts())}else null!==hoveredPointIndex&&(hoveredPointIndex=null,updateAllCharts())}};if(pc1Chart)pc1Chart.data.datasets[0].data=pc1Data,pc1Chart.options.scales.x.min=minProj1-padding1,pc1Chart.options.scales.x.max=maxProj1+padding1,pc1Chart.update("none");else{const ctx1=document.getElementById("pc1-projection").getContext("2d");pc1Chart=new Chart(ctx1,{type:"scatter",data:{datasets:[{data:pc1Data,backgroundColor:"rgba(255, 107, 53, 0.7)",pointRadius:4,pointHoverRadius:6}]},options:{...commonOptions,scales:{...commonOptions.scales,x:{min:minProj1-padding1,max:maxProj1+padding1,title:{display:!0,text:"PC1 projection"},grid:{color:"rgba(0,0,0,0.05)"}}}}})}if(pc2Chart)pc2Chart.data.datasets[0].data=pc2Data,pc2Chart.options.scales.x.min=minProj2-padding2,pc2Chart.options.scales.x.max=maxProj2+padding2,pc2Chart.update("none");else{const ctx2=document.getElementById("pc2-projection").getContext("2d");pc2Chart=new Chart(ctx2,{type:"scatter",data:{datasets:[{data:pc2Data,backgroundColor:"rgba(106, 76, 147, 0.7)",pointRadius:4,pointHoverRadius:6}]},options:{...commonOptions,scales:{...commonOptions.scales,x:{min:minProj2-padding2,max:maxProj2+padding2,title:{display:!0,text:"PC2 projection"},grid:{color:"rgba(0,0,0,0.05)"}}}}})}}function updateAllCharts(){scatterChart&&scatterChart.update("none"),pc1Chart&&pc1Chart.update("none"),pc2Chart&&pc2Chart.update("none")}function updateChart(){if(!currentAnalysis)return;const componentLines=buildComponentLines(currentAnalysis),datasets=[{type:"scatter",label:"Data points",data:currentPoints,backgroundColor:"rgba(33, 78, 138, 0.85)",pointRadius:4,pointHoverRadius:6},{type:"line",label:"PC1",data:componentLines.pc1,borderColor:"#ff6b35",borderWidth:3,pointRadius:0,tension:0,borderDash:[]},{type:"line",label:"PC2",data:componentLines.pc2,borderColor:"#6a4c93",borderWidth:2,pointRadius:0,tension:0,borderDash:[6,6]}],scales={x:{min:currentAnalysis.bounds.x.min,max:currentAnalysis.bounds.x.max,title:{display:!0,text:"x"},grid:{color:"rgba(0,0,0,0.05)"}},y:{min:currentAnalysis.bounds.y.min,max:currentAnalysis.bounds.y.max,title:{display:!0,text:"y"},grid:{color:"rgba(0,0,0,0.05)"}}};if(scatterChart)scatterChart.data.datasets=datasets,scatterChart.options.scales.x.min=scales.x.min,scatterChart.options.scales.x.max=scales.x.max,scatterChart.options.scales.y.min=scales.y.min,scatterChart.options.scales.y.max=scales.y.max,scatterChart.update("none");else{const ctx=document.getElementById("pca-plot").getContext("2d");scatterChart=new Chart(ctx,{type:"scatter",data:{datasets:datasets},options:{animation:!1,responsive:!0,maintainAspectRatio:!1,plugins:{legend:{display:!0},tooltip:{callbacks:{label(context){const{x:x,y:y}=context.parsed;return`${context.dataset.label}: (${x.toFixed(2)}, ${y.toFixed(2)})`}}}},scales:scales,onHover:(event,activeElements)=>{if(activeElements.length>0&&0===activeElements[0].datasetIndex){const newIndex=activeElements[0].index;hoveredPointIndex!==newIndex&&(hoveredPointIndex=newIndex,updateAllCharts())}else null!==hoveredPointIndex&&(hoveredPointIndex=null,updateAllCharts())}}})}}function updateSummaryPanels(){if(!currentAnalysis)return statCount.textContent="0",statCorr.textContent="0.00",statMean.textContent="(0.00, 0.00)",pc1Variance.textContent="0%",pc2Variance.textContent="0%",varianceSummary.textContent="Adjust a slider to see how the variance redistributes.",covXX.textContent="0.00",covXY.textContent="0.00",covYX.textContent="0.00",void(covYY.textContent="0.00");const{varianceRatios:varianceRatios,covariance:covariance,mean:mean,sampleCorr:sampleCorr}=currentAnalysis;statCount.textContent=state.count.toString(),statCorr.textContent=sampleCorr.toFixed(2),statMean.textContent=`(${mean.x.toFixed(2)}, ${mean.y.toFixed(2)})`,pc1Variance.textContent=formatPercent(varianceRatios[0]||0),pc2Variance.textContent=formatPercent(varianceRatios[1]||0),varianceSummary.textContent=`PC1 captures ${formatPercent(varianceRatios[0]||0)} of the variance; PC2 accounts for the remaining ${formatPercent(varianceRatios[1]||0)}.`,covXX.textContent=covariance.xx.toFixed(2),covXY.textContent=covariance.xy.toFixed(2),covYX.textContent=covariance.xy.toFixed(2),covYY.textContent=covariance.yy.toFixed(2)}function updateDataset({regenerateBase:regenerateBase=!1}={}){regenerateBase||0===state.randomBase.length?rebuildRandomBase():ensureRandomBase(state.count),currentPoints=generatePoints(),currentAnalysis=analyzePoints(currentPoints),updateSummaryPanels(),updateChart(),updateProjectionPlots()}function syncControls(){correlationControl.value=state.correlation,noiseControl.value=state.noise,countControl.value=state.count,meanXInput.value=state.meanX,meanYInput.value=state.meanY,correlationValue.textContent=Number(state.correlation).toFixed(2),noiseValue.textContent=Number(state.noise).toFixed(2),countValue.textContent=state.count.toString()}function resetToDefaults(){Object.assign(state,defaults),state.randomBase=[],syncControls(),updateDataset({regenerateBase:!0})}function setupControlEvents(){correlationControl.addEventListener("input",event=>{state.correlation=Number(event.target.value),correlationValue.textContent=state.correlation.toFixed(2),updateDataset()}),noiseControl.addEventListener("input",event=>{state.noise=Number(event.target.value),noiseValue.textContent=state.noise.toFixed(2),updateDataset()}),countControl.addEventListener("input",event=>{state.count=Number(event.target.value),countValue.textContent=state.count.toString(),updateDataset()}),meanXInput.addEventListener("change",event=>{state.meanX=Number(event.target.value)||0,updateDataset()}),meanYInput.addEventListener("change",event=>{state.meanY=Number(event.target.value)||0,updateDataset()}),resetButton.addEventListener("click",()=>{resetToDefaults()}),regenerateButton.addEventListener("click",()=>{updateDataset({regenerateBase:!0})})}Chart.register(highlightPlugin),new InfoTab,resetToDefaults(),setupControlEvents();