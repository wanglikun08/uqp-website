class RNNDemo{constructor(){this.inputCanvas=document.getElementById("input-canvas"),this.rnnCanvas=document.getElementById("rnn-canvas"),this.outputCanvas=document.getElementById("output-canvas"),this.inputCtx=this.inputCanvas.getContext("2d"),this.rnnCtx=this.rnnCanvas.getContext("2d"),this.outputCtx=this.outputCanvas.getContext("2d"),this.stepBtn=document.getElementById("step-btn"),this.resetBtn=document.getElementById("reset-btn"),this.optimiseBtn=document.getElementById("optimise-btn"),this.trainBtn=document.getElementById("train-btn"),this.configureCanvases(),this.sequences={fibonacci:[1,1,2,3,5,8,13,21,34,55],linear:[1,2,3,4,5,6,7,8,9,10],alternating:[1,-1,1,-1,1,-1,1,-1,1,-1],exponential:[1,2,4,8,16,32,64,128,256,512],sine:[0,.71,1,.71,0,-.71,-1,-.71,0,.71]},this.selectedSequence="fibonacci",this.selectedActivation="tanh",this.normalize=!1,this.currentLoss=null,this.currentGradNorm=null,this.setupPhoebeComponents(),this.reset(),this.setupEventListeners(),this.render()}setupPhoebeComponents(){this.inputWeightSlider=new ParamSlider("paramslider-input-weight",{inputId:"input-weight",label:"$W_{input}$ (Input Weight)",min:-5,max:5,step:.05,value:1,decimals:2,onChange:()=>this.render()}),this.hiddenWeightSlider=new ParamSlider("paramslider-hidden-weight",{inputId:"hidden-weight",label:"$W_{hidden}$ (Hidden Weight)",min:-5,max:5,step:.05,value:.5,decimals:2,onChange:()=>this.render()}),this.biasSlider=new ParamSlider("paramslider-hidden-bias",{inputId:"hidden-bias",label:"$b_{hidden}$ (Hidden Bias)",min:-5,max:5,step:.05,value:0,decimals:2,onChange:()=>this.render()}),this.outputWeightSlider=new ParamSlider("paramslider-output-weight",{inputId:"output-weight",label:"$W_{output}$ (Output Weight)",min:-5,max:5,step:.05,value:1,decimals:2,onChange:()=>this.render()}),this.outputBiasSlider=new ParamSlider("paramslider-output-bias",{inputId:"output-bias",label:"$b_{output}$ (Output Bias)",min:-5,max:5,step:.05,value:0,decimals:2,onChange:()=>this.render()}),this.learningRateSlider=new ParamSlider("paramslider-learning-rate",{inputId:"learning-rate",label:"Learning Rate",min:.001,max:.5,step:.001,value:.01,decimals:3,onChange:()=>{}})}configureCanvases(){const input=CanvasHelper.setupCanvas(this.inputCanvas,{ctx:this.inputCtx}),rnn=CanvasHelper.setupCanvas(this.rnnCanvas,{ctx:this.rnnCtx}),output=CanvasHelper.setupCanvas(this.outputCanvas,{ctx:this.outputCtx});this.inputCtx=input.ctx,this.rnnCtx=rnn.ctx,this.outputCtx=output.ctx}setupEventListeners(){const fancyPanels=document.querySelectorAll(".controls .fancybox-panel"),sequenceBoxes=fancyPanels[0]?fancyPanels[0].querySelectorAll(".fancybox"):[];sequenceBoxes.forEach(box=>{box.addEventListener("click",()=>{sequenceBoxes.forEach(b=>b.classList.remove("active")),box.classList.add("active"),this.selectedSequence=box.dataset.type,this.reset(),this.render()})});const activationBoxes=fancyPanels[1]?fancyPanels[1].querySelectorAll(".fancybox"):[];activationBoxes.forEach(box=>{box.addEventListener("click",()=>{activationBoxes.forEach(b=>b.classList.remove("active")),box.classList.add("active"),this.selectedActivation=box.dataset.type,this.render()})});const scalingBoxes=fancyPanels[2]?fancyPanels[2].querySelectorAll(".fancybox"):[];scalingBoxes.forEach(box=>{box.addEventListener("click",()=>{scalingBoxes.forEach(b=>b.classList.remove("active")),box.classList.add("active"),this.normalize="normalized"===box.dataset.type,this.reset(),this.render()})}),this.stepBtn.addEventListener("click",()=>this.step()),this.resetBtn.addEventListener("click",()=>{this.reset(),this.render()}),this.optimiseBtn.addEventListener("click",()=>this.optimise()),this.trainBtn.addEventListener("click",()=>this.trainBPTT())}reset(){if(this.currentTimestep=0,this.hiddenState=0,this.outputs=[],this.hiddenStates=[],this.gradientHistory=[],this.currentSequence=[...this.sequences[this.selectedSequence]],this.normalize){const maxAbs=Math.max(...this.currentSequence.map(v=>Math.abs(v)))||1;this.currentSequence=this.currentSequence.map(v=>v/maxAbs)}this.resetHistoryTable(),this.stepBtn.disabled=!1,this.freeRunBtn&&(this.freeRunBtn.textContent="Free-Running OFF",this.freeRunBtn.classList.remove("active")),this.currentLoss=null,this.currentGradNorm=null,this.updateMetrics()}updateMetrics(){const lossLabel=document.getElementById("metric-loss");lossLabel&&null!==this.currentLoss?lossLabel.textContent=this.currentLoss.toFixed(4):lossLabel&&(lossLabel.textContent="-");const gradLabel=document.getElementById("metric-gradnorm");gradLabel&&null!==this.currentGradNorm?gradLabel.textContent=this.currentGradNorm.toFixed(4):gradLabel&&(gradLabel.textContent="-")}resetHistoryTable(){const historyBody=document.getElementById("historyBody");historyBody&&(historyBody.innerHTML='\n            <tr class="history-row-step">\n                <th>Step</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-input">\n                <th>Input (x<sub>t</sub>)</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-expected">\n                <th>Expected Next</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-output">\n                <th>Actual Output (y<sub>t</sub>)</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-error">\n                <th>Error (Δ)</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-expected-delta">\n                <th>Expected Δ Output</th>\n                <td class="current-iteration">-</td>\n            </tr>\n            <tr class="history-row-actual-delta">\n                <th>Actual Δ Output</th>\n                <td class="current-iteration">-</td>\n            </tr>\n        ')}step(){if(this.currentTimestep<this.currentSequence.length){const input=this.currentSequence[this.currentTimestep],inputWeight=this.inputWeightSlider.value,hiddenWeight=this.hiddenWeightSlider.value,bias=this.biasSlider.value,preActivation=inputWeight*input+hiddenWeight*this.hiddenState+bias;this.hiddenState=this.applyActivation(preActivation);const outputWeight=this.outputWeightSlider.value,outputBias=this.outputBiasSlider.value,output=outputWeight*this.hiddenState+outputBias;this.outputs.push(output),this.hiddenStates.push(this.hiddenState);const expectedNext=this.currentTimestep<this.currentSequence.length-1?this.currentSequence[this.currentTimestep+1]:null,error=null!==expectedNext?output-expectedNext:null,expectedDelta=this.currentTimestep<this.currentSequence.length-1?this.currentSequence[this.currentTimestep+1]-this.currentSequence[this.currentTimestep]:null,actualDelta=this.outputs.length>1?output-this.outputs[this.outputs.length-2]:null;this.addHistoryColumn(this.currentTimestep,input,expectedNext,output,error,expectedDelta,actualDelta),this.currentTimestep++,this.currentTimestep>=this.currentSequence.length&&(this.stepBtn.disabled=!0),this.render()}}addHistoryColumn(step,input,expectedNext,actualOutput,error,expectedDelta,actualDelta){const rows=[document.querySelector(".history-row-step"),document.querySelector(".history-row-input"),document.querySelector(".history-row-expected"),document.querySelector(".history-row-output"),document.querySelector(".history-row-error"),document.querySelector(".history-row-expected-delta"),document.querySelector(".history-row-actual-delta")];if(!rows[0])return;const formatValue=val=>this.formatValue(val),currentIterationCells=document.querySelectorAll(".current-iteration");currentIterationCells.length>0&&"-"===currentIterationCells[0].textContent.trim()?(rows[0].querySelector(".current-iteration").textContent=step,rows[1].querySelector(".current-iteration").textContent=formatValue(input),rows[2].querySelector(".current-iteration").textContent=formatValue(expectedNext),rows[3].querySelector(".current-iteration").textContent=formatValue(actualOutput),rows[4].querySelector(".current-iteration").textContent=formatValue(error),rows[5].querySelector(".current-iteration").textContent=formatValue(expectedDelta),rows[6].querySelector(".current-iteration").textContent=formatValue(actualDelta)):(currentIterationCells.forEach(cell=>{cell.classList.remove("current-iteration")}),rows[0].insertAdjacentHTML("beforeend",`<td class="current-iteration">${step}</td>`),rows[1].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(input)}</td>`),rows[2].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(expectedNext)}</td>`),rows[3].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(actualOutput)}</td>`),rows[4].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(error)}</td>`),rows[5].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(expectedDelta)}</td>`),rows[6].insertAdjacentHTML("beforeend",`<td class="current-iteration">${formatValue(actualDelta)}</td>`));const scrollContainer=document.getElementById("historyScroll");scrollContainer&&(scrollContainer.scrollLeft=scrollContainer.scrollWidth)}optimise(){let bestInputWeight=0,bestHiddenWeight=0,bestBias=0,bestOutputWeight=1,bestOutputBias=0,bestLoss=1/0;for(let i=0;i<500;i++){const inputWeight=10*Math.random()-5,hiddenWeight=10*Math.random()-5,bias=10*Math.random()-5,outputWeight=10*Math.random()-5,outputBias=10*Math.random()-5,loss=this.computeLoss(inputWeight,hiddenWeight,bias,outputWeight,outputBias);loss<bestLoss&&(bestLoss=loss,bestInputWeight=inputWeight,bestHiddenWeight=hiddenWeight,bestBias=bias,bestOutputWeight=outputWeight,bestOutputBias=outputBias)}for(let iw=-2;iw<=2;iw+=.5)for(let hw=-2;hw<=2;hw+=.5)for(let b=-2;b<=2;b+=.5)for(let ow=-2;ow<=2;ow+=.5)for(let ob=-2;ob<=2;ob+=.5){const inputWeight=Math.max(-5,Math.min(5,bestInputWeight+iw)),hiddenWeight=Math.max(-5,Math.min(5,bestHiddenWeight+hw)),bias=Math.max(-5,Math.min(5,bestBias+b)),outputWeight=Math.max(-5,Math.min(5,bestOutputWeight+ow)),outputBias=Math.max(-5,Math.min(5,bestOutputBias+ob)),loss=this.computeLoss(inputWeight,hiddenWeight,bias,outputWeight,outputBias);loss<bestLoss&&(bestLoss=loss,bestInputWeight=inputWeight,bestHiddenWeight=hiddenWeight,bestBias=bias,bestOutputWeight=outputWeight,bestOutputBias=outputBias)}this.inputWeightSlider.setValue(Math.round(20*bestInputWeight)/20),this.hiddenWeightSlider.setValue(Math.round(20*bestHiddenWeight)/20),this.biasSlider.setValue(Math.round(20*bestBias)/20),this.outputWeightSlider.setValue(Math.round(20*bestOutputWeight)/20),this.outputBiasSlider.setValue(Math.round(20*bestOutputBias)/20),this.currentLoss=bestLoss,this.currentGradNorm=null,this.updateMetrics(),this.reset(),this.render()}computeLoss(inputWeight,hiddenWeight,bias,outputWeight,outputBias){let hiddenState=0,totalError=0,count=0;for(let t=0;t<this.currentSequence.length-1;t++){const input=this.currentSequence[t],target=this.currentSequence[t+1],preActivation=inputWeight*input+hiddenWeight*hiddenState+bias;hiddenState=this.applyActivation(preActivation);const error=outputWeight*hiddenState+outputBias-target;totalError+=error*error,count++}return count>0?totalError/count:1/0}trainBPTT(){const learningRate=this.learningRateSlider.value;for(let epoch=0;epoch<50;epoch++){let hiddenState=0;const hiddenStates=[0],preActivations=[],outputs=[];for(let t=0;t<this.currentSequence.length-1;t++){const input=this.currentSequence[t],inputWeight=this.inputWeightSlider.value,hiddenWeight=this.hiddenWeightSlider.value,bias=this.biasSlider.value,outputWeight=this.outputWeightSlider.value,outputBias=this.outputBiasSlider.value,preAct=inputWeight*input+hiddenWeight*hiddenState+bias;hiddenState=this.applyActivation(preAct);const output=outputWeight*hiddenState+outputBias;preActivations.push(preAct),hiddenStates.push(hiddenState),outputs.push(output)}let dInputWeight=0,dHiddenWeight=0,dBias=0,dOutputWeight=0,dOutputBias=0,dHiddenNext=0;for(let t=this.currentSequence.length-2;t>=0;t--){const input=this.currentSequence[t],target=this.currentSequence[t+1],output=outputs[t],hiddenState=hiddenStates[t+1],preAct=preActivations[t],dOutput=2*(output-target)/(this.currentSequence.length-1);dOutputWeight+=dOutput*hiddenState,dOutputBias+=dOutput;const dPreAct=(dOutput*this.outputWeightSlider.value+dHiddenNext)*this.applyActivationDerivative(preAct);dInputWeight+=dPreAct*input,dHiddenWeight+=dPreAct*hiddenStates[t],dBias+=dPreAct,dHiddenNext=dPreAct*this.hiddenWeightSlider.value}const clipValue=5;dInputWeight=Math.max(-clipValue,Math.min(clipValue,dInputWeight)),dHiddenWeight=Math.max(-clipValue,Math.min(clipValue,dHiddenWeight)),dBias=Math.max(-clipValue,Math.min(clipValue,dBias)),dOutputWeight=Math.max(-clipValue,Math.min(clipValue,dOutputWeight)),dOutputBias=Math.max(-clipValue,Math.min(clipValue,dOutputBias)),this.inputWeightSlider.setValue(this.inputWeightSlider.value-learningRate*dInputWeight),this.hiddenWeightSlider.setValue(this.hiddenWeightSlider.value-learningRate*dHiddenWeight),this.biasSlider.setValue(this.biasSlider.value-learningRate*dBias),this.outputWeightSlider.setValue(this.outputWeightSlider.value-learningRate*dOutputWeight),this.outputBiasSlider.setValue(this.outputBiasSlider.value-learningRate*dOutputBias);const gradNorm=Math.sqrt(dInputWeight**2+dHiddenWeight**2+dBias**2+dOutputWeight**2+dOutputBias**2);if(epoch%5==0&&this.gradientHistory.push(gradNorm),49===epoch){const finalLoss=this.computeLoss(this.inputWeightSlider.value,this.hiddenWeightSlider.value,this.biasSlider.value,this.outputWeightSlider.value,this.outputBiasSlider.value);this.currentLoss=finalLoss,this.currentGradNorm=gradNorm}}const savedLoss=this.currentLoss,savedGradNorm=this.currentGradNorm;this.reset(),this.render(),this.currentLoss=savedLoss,this.currentGradNorm=savedGradNorm,this.updateMetrics()}applyActivationDerivative(x){switch(this.selectedActivation){case"linear":default:return 1;case"relu":return x>0?1:0;case"sigmoid":const sig=1/(1+Math.exp(-x));return sig*(1-sig);case"tanh":const th=Math.tanh(x);return 1-th*th}}applyActivation(x){switch(this.selectedActivation){case"linear":default:return x;case"relu":return Math.max(0,x);case"sigmoid":return 1/(1+Math.exp(-x));case"tanh":return Math.tanh(x)}}formatValue(val){if(null==val)return"-";if("number"!=typeof val)return val.toString();if(this.normalize){const formatted=val.toFixed(2);return parseFloat(formatted).toString()}if(Number.isInteger(val))return val.toString();{const formatted=val.toFixed(2);return parseFloat(formatted).toString()}}render(){this.clearCanvases(),this.drawInputSequence(),this.drawRNNCell(),this.drawOutput()}clearCanvases(){const canvases=[this.inputCanvas,this.rnnCanvas,this.outputCanvas];[this.inputCtx,this.rnnCtx,this.outputCtx].forEach((ctx,i)=>{ctx.clearRect(0,0,canvases[i].width,canvases[i].height)})}drawInputSequence(){const ctx=this.inputCtx,canvas=this.inputCanvas,width=canvas.clientWidth,height=canvas.clientHeight,sequence=this.currentSequence,cellWidth=width/sequence.length,startY=(height-60)/2;if(sequence.forEach((value,index)=>{const x=index*cellWidth+.1*cellWidth,y=startY,w=.8*cellWidth;index===this.currentTimestep&&this.currentTimestep<sequence.length?(ctx.fillStyle="#ffd700",ctx.strokeStyle="#ff8c00",ctx.lineWidth=3):index<this.currentTimestep?(ctx.fillStyle="#e3f2fd",ctx.strokeStyle="#1976d2",ctx.lineWidth=2):(ctx.fillStyle="#f5f5f5",ctx.strokeStyle="#ccc",ctx.lineWidth=1),ctx.fillRect(x,y,w,60),ctx.strokeRect(x,y,w,60),ctx.fillStyle="#333",ctx.font="16px Arial",ctx.textAlign="center",ctx.textBaseline="middle";const displayValue=this.formatValue(value);ctx.fillText(displayValue,x+w/2,y+30),ctx.font="12px Arial",ctx.fillStyle="#666",ctx.fillText(`t=${index}`,x+w/2,y+60+15)}),this.currentTimestep<sequence.length){const arrowX=this.currentTimestep*cellWidth+cellWidth/2,arrowY=startY-20;ctx.fillStyle="#ff6b6b",ctx.beginPath(),ctx.moveTo(arrowX,arrowY),ctx.lineTo(arrowX-8,arrowY-15),ctx.lineTo(arrowX+8,arrowY-15),ctx.closePath(),ctx.fill()}}drawRNNCell(){const ctx=this.rnnCtx,canvas=this.rnnCanvas,centerX=canvas.clientWidth/2,centerY=.35*canvas.clientHeight,cellX=centerX-60,cellY=centerY-40;ctx.fillStyle="#f3e5f5",ctx.strokeStyle="#7b1fa2",ctx.lineWidth=3,ctx.fillRect(cellX,cellY,120,80),ctx.strokeRect(cellX,cellY,120,80),ctx.fillStyle="#333",ctx.font="bold 16px Arial",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText("RNN",centerX,centerY-15),ctx.font="14px Arial",ctx.textAlign="center";const biasValue=this.biasSlider.value.toFixed(1);ctx.fillText("b",centerX-20,centerY+5),ctx.font="10px Arial",ctx.fillText("h",centerX-13,centerY+9),ctx.font="14px Arial",ctx.fillText(`= ${biasValue}`,centerX+5,centerY+5),ctx.fillText(`f = ${this.selectedActivation}`,centerX,centerY+20);const hiddenPrevX=centerX-150,hiddenPrevY=centerY;ctx.fillStyle="#fff3e0",ctx.strokeStyle="#f57c00",ctx.lineWidth=3,ctx.beginPath(),ctx.arc(hiddenPrevX,hiddenPrevY,25,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.fillStyle="#333",ctx.font="bold 16px Arial",ctx.textAlign="center",ctx.fillText("h",hiddenPrevX-8,hiddenPrevY),ctx.font="10px Arial",ctx.fillText("t-1",hiddenPrevX+8,hiddenPrevY+8);const prevHidden=this.hiddenState;ctx.font="13px Arial",ctx.fillStyle="#f57c00",ctx.fillText(this.formatValue(prevHidden),hiddenPrevX,hiddenPrevY+35);const inputX=centerX,inputY=centerY+100;if(ctx.fillStyle="#e3f2fd",ctx.strokeStyle="#1976d2",ctx.lineWidth=3,ctx.beginPath(),ctx.arc(inputX,inputY,25,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.fillStyle="#333",ctx.font="bold 18px Arial",ctx.textAlign="center",ctx.fillText("x",inputX-6,inputY),ctx.font="11px Arial",ctx.fillText("t",inputX+6,inputY+6),this.currentTimestep<this.currentSequence.length){const currentInput=this.currentSequence[this.currentTimestep];ctx.font="13px Arial",ctx.fillStyle="#1976d2",ctx.fillText(this.formatValue(currentInput),inputX,inputY+35)}const outputX=centerX+150,outputY=centerY;ctx.fillStyle="#e8f5e8",ctx.strokeStyle="#388e3c",ctx.lineWidth=3,ctx.beginPath(),ctx.arc(outputX,outputY,25,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.fillStyle="#333",ctx.font="bold 18px Arial",ctx.textAlign="center",ctx.fillText("h",outputX-6,outputY),ctx.font="11px Arial",ctx.fillText("t",outputX+6,outputY+6),ctx.font="13px Arial",ctx.fillStyle="#388e3c",ctx.fillText(this.formatValue(this.hiddenState),outputX,outputY+35);const yOutputX=outputX,yOutputY=centerY+100;if(ctx.fillStyle="#fff9e6",ctx.strokeStyle="#ff9800",ctx.lineWidth=3,ctx.beginPath(),ctx.arc(yOutputX,yOutputY,25,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.fillStyle="#333",ctx.font="bold 18px Arial",ctx.textAlign="center",ctx.fillText("y",yOutputX-6,yOutputY),ctx.font="11px Arial",ctx.fillText("t",yOutputX+6,yOutputY+6),this.outputs.length>0){const currentOutput=this.outputs[this.outputs.length-1];ctx.font="13px Arial",ctx.fillStyle="#ff9800",ctx.fillText(this.formatValue(currentOutput),yOutputX,yOutputY+35)}this.drawConnection(ctx,hiddenPrevX+25,hiddenPrevY,cellX,centerY,`W_{h}=${this.hiddenWeightSlider.value.toFixed(1)}`,"#f57c00",{x:(hiddenPrevX+25+cellX)/2,y:centerY-15});const inputLabelX=inputX+25,inputLabelY=(inputY-25+cellY+80)/2;this.drawConnection(ctx,inputX,inputY-25,centerX,cellY+80,`W_{i}=${this.inputWeightSlider.value.toFixed(1)}`,"#1976d2",{x:inputLabelX,y:inputLabelY}),this.drawConnection(ctx,cellX+120,centerY,outputX-25,outputY,"","#388e3c");const outputProjLabelX=outputX+25,outputProjLabelY=(outputY+25+yOutputY-25)/2;this.drawConnection(ctx,outputX,outputY+25,yOutputX,yOutputY-25,`W_{o}=${this.outputWeightSlider.value.toFixed(1)}`,"#ff9800",{x:outputProjLabelX,y:outputProjLabelY})}drawConnection(ctx,x1,y1,x2,y2,label,color,labelOffset=null){ctx.strokeStyle=color,ctx.lineWidth=2,ctx.beginPath(),ctx.moveTo(x1,y1),ctx.lineTo(x2,y2),ctx.stroke();const angle=Math.atan2(y2-y1,x2-x1);if(ctx.beginPath(),ctx.moveTo(x2,y2),ctx.lineTo(x2-8*Math.cos(angle-Math.PI/6),y2-8*Math.sin(angle-Math.PI/6)),ctx.lineTo(x2-8*Math.cos(angle+Math.PI/6),y2-8*Math.sin(angle+Math.PI/6)),ctx.closePath(),ctx.fillStyle=color,ctx.fill(),label){let labelX,labelY;labelOffset?(labelX=labelOffset.x,labelY=labelOffset.y):(labelX=(x1+x2)/2,labelY=(y1+y2)/2-5),ctx.fillStyle=color,this.drawMathLabel(ctx,label,labelX,labelY)}}drawMathLabel(ctx,label,x,y){if(label.includes("W_{h}=")){const value=label.split("=")[1];ctx.font="bold 12px Arial",ctx.textAlign="center",ctx.fillText("W",x-15,y),ctx.font="9px Arial",ctx.fillText("h",x-7,y+5),ctx.font="12px Arial",ctx.fillText("=",x+2,y),ctx.fillText(value,x+12,y)}else if(label.includes("W_{i}=")){const value=label.split("=")[1];ctx.font="bold 12px Arial",ctx.textAlign="center",ctx.fillText("W",x-15,y),ctx.font="9px Arial",ctx.fillText("i",x-7,y+5),ctx.font="12px Arial",ctx.fillText("=",x+2,y),ctx.fillText(value,x+12,y)}else if(label.includes("W_{o}=")){const value=label.split("=")[1];ctx.font="bold 12px Arial",ctx.textAlign="center",ctx.fillText("W",x-15,y),ctx.font="9px Arial",ctx.fillText("o",x-7,y+5),ctx.font="12px Arial",ctx.fillText("=",x+2,y),ctx.fillText(value,x+12,y)}else ctx.font="12px Arial",ctx.textAlign="center",ctx.fillText(label,x,y)}drawOutput(){const ctx=this.outputCtx,canvas=this.outputCanvas,width=canvas.clientWidth||canvas.width,height=canvas.clientHeight||canvas.height;if(!this.currentSequence||0===this.currentSequence.length)return;this.outputs;const cellWidth=width/this.currentSequence.length,startY=(height-60)/2;this.outputs.forEach((output,index)=>{const x=index*cellWidth+.1*cellWidth,y=startY,w=.8*cellWidth;ctx.fillStyle="#e8f5e8",ctx.strokeStyle="#388e3c",ctx.lineWidth=2,ctx.fillRect(x,y,w,60),ctx.strokeRect(x,y,w,60),ctx.fillStyle="#333",ctx.font="16px Arial",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(this.formatValue(output),x+w/2,y+30),ctx.font="12px Arial",ctx.fillStyle="#666",ctx.fillText(`t=${index}`,x+w/2,y+60+15)});for(let index=this.outputs.length;index<this.currentSequence.length;index++){const x=index*cellWidth+.1*cellWidth,y=startY,w=.8*cellWidth,h=60;ctx.fillStyle="#f5f5f5",ctx.strokeStyle="#ccc",ctx.lineWidth=1,ctx.fillRect(x,y,w,h),ctx.strokeRect(x,y,w,h),ctx.font="12px Arial",ctx.fillStyle="#666",ctx.textAlign="center",ctx.fillText(`t=${index}`,x+w/2,y+h+15)}}}