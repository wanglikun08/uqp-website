let state={data:null,currentDegree:1,showTest:!1,showSquaredErrors:!1,charts:{scatter:null,error:null},displays:null};async function loadData(){try{const response=await fetch("data/bias_variance_data.json");state.data=await response.json(),console.log(`Loaded ${state.data.train_data.x.length} train points`),console.log(`Loaded ${state.data.test_data.x.length} test points`),console.log(`True function: ${state.data.metadata.true_function}`)}catch(error){console.error("Failed to load data:",error),alert("Failed to load demo data. Please check that bias_variance_data.json exists.")}}class PolynomialRegression{constructor(degree){this.degree=degree,this.coefficients=null}createFeatures(X){const n=X.length,features=[];for(let i=0;i<n;i++){const row=[];for(let d=0;d<=this.degree;d++)row.push(Math.pow(X[i],d));features.push(row)}return features}fit(X,y){const features=this.createFeatures(X),XtX=this.matrixMultiply(this.transpose(features),features),Xty=this.matrixVectorMultiply(this.transpose(features),y);this.coefficients=this.solveLinearSystem(XtX,Xty)}predict(X){if(!this.coefficients)throw new Error("Model not fitted");return this.createFeatures(X).map(row=>row.reduce((sum,val,idx)=>sum+val*this.coefficients[idx],0))}matrixMultiply(A,B){const result=[];for(let i=0;i<A.length;i++){result[i]=[];for(let j=0;j<B[0].length;j++){let sum=0;for(let k=0;k<A[0].length;k++)sum+=A[i][k]*B[k][j];result[i][j]=sum}}return result}matrixVectorMultiply(A,v){return A.map(row=>row.reduce((sum,val,idx)=>sum+val*v[idx],0))}transpose(matrix){return matrix[0].map((_,colIndex)=>matrix.map(row=>row[colIndex]))}solveLinearSystem(A,b){const n=A.length,augmented=A.map((row,i)=>[...row,b[i]]);for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];for(let k=i+1;k<n;k++){const factor=augmented[k][i]/augmented[i][i];for(let j=i;j<=n;j++)augmented[k][j]-=factor*augmented[i][j]}}const x=new Array(n);for(let i=n-1;i>=0;i--){x[i]=augmented[i][n];for(let j=i+1;j<n;j++)x[i]-=augmented[i][j]*x[j];x[i]/=augmented[i][i]}return x}}function calculateMSE(yTrue,yPred){const n=yTrue.length;let sumSquaredError=0;for(let i=0;i<n;i++){const error=yTrue[i]-yPred[i];sumSquaredError+=error*error}return sumSquaredError/n}const squaredErrorsPlugin={id:"squaredErrors",afterDatasetsDraw(chart){if(!state.showSquaredErrors||!state.data)return;const ctx=chart.ctx,xScale=chart.scales.x,yScale=chart.scales.y,coeffs=state.data.fitted_coefficients[state.currentDegree.toString()];ctx.save(),ctx.lineWidth=1;const trainData=state.data.train_data;ctx.fillStyle="rgba(33, 150, 243, 0.15)",ctx.strokeStyle="rgba(33, 150, 243, 0.4)";for(let i=0;i<trainData.x.length;i++){const x=trainData.x[i],yActual=trainData.y[i];let yPred=0;for(let j=0;j<coeffs.length;j++)yPred+=coeffs[j]*Math.pow(x,j);const xPixel=xScale.getPixelForValue(x),yActualPixel=yScale.getPixelForValue(yActual),yPredPixel=yScale.getPixelForValue(yPred),errorPixels=Math.abs(yActualPixel-yPredPixel),left=xPixel,top=Math.min(yActualPixel,yPredPixel);ctx.fillRect(left,top,errorPixels,errorPixels),ctx.strokeRect(left,top,errorPixels,errorPixels)}if(state.showTest){const testData=state.data.test_data;ctx.fillStyle="rgba(255, 152, 0, 0.15)",ctx.strokeStyle="rgba(255, 152, 0, 0.4)";for(let i=0;i<testData.x.length;i++){const x=testData.x[i],yActual=testData.y[i];let yPred=0;for(let j=0;j<coeffs.length;j++)yPred+=coeffs[j]*Math.pow(x,j);const xPixel=xScale.getPixelForValue(x),yActualPixel=yScale.getPixelForValue(yActual),yPredPixel=yScale.getPixelForValue(yPred),errorPixels=Math.abs(yActualPixel-yPredPixel),left=xPixel,top=Math.min(yActualPixel,yPredPixel);ctx.fillRect(left,top,errorPixels,errorPixels),ctx.strokeRect(left,top,errorPixels,errorPixels)}}ctx.restore()}};function initCharts(){const scatterCtx=document.getElementById("scatterPlot").getContext("2d"),trainData=state.data.train_data;state.data.test_data;state.charts.scatter=new Chart(scatterCtx,{type:"scatter",plugins:[squaredErrorsPlugin],data:{datasets:[{label:"Training Data",data:trainData.x.map((x,i)=>({x:x,y:trainData.y[i]})),backgroundColor:"rgba(33, 150, 243, 0.5)",borderColor:"rgba(33, 150, 243, 1)",pointRadius:5},{label:"Test Data",data:[],backgroundColor:"rgba(255, 152, 0, 0.5)",borderColor:"rgba(255, 152, 0, 1)",pointRadius:4},{label:"Degree 1 Polynomial",data:[],type:"line",borderColor:"rgba(220, 38, 38, 1)",borderWidth:3,fill:!1,pointRadius:0}]},options:{responsive:!0,maintainAspectRatio:!1,animation:{duration:300,easing:"easeInOutQuad"},plugins:{legend:{display:!0,position:"top"},title:{display:!1}},scales:{x:{type:"linear",position:"bottom",title:{display:!0,text:"x"},min:0,max:11},y:{title:{display:!0,text:"y"},min:-50,max:500}}}});const errorCtx=document.getElementById("errorChart").getContext("2d"),highlightBandPlugin={id:"highlightBand",beforeDatasetsDraw(chart){if(!state.data)return;const ctx=chart.ctx,xScale=chart.scales.x,yScale=chart.scales.y,barIndex=state.currentDegree-1,xLeft=xScale.getPixelForValue(barIndex)-xScale.width/xScale.ticks.length/2,xRight=xScale.getPixelForValue(barIndex)+xScale.width/xScale.ticks.length/2,yTop=yScale.top,yBottom=yScale.bottom;ctx.save(),ctx.fillStyle="rgba(255, 235, 59, 0.15)",ctx.fillRect(xLeft,yTop,xRight-xLeft,yBottom-yTop),ctx.restore()}};state.charts.error=new Chart(errorCtx,{type:"bar",plugins:[highlightBandPlugin],data:{labels:["1","2","3","4","5","6","7","8","9","10"],datasets:[{label:"Train MSE",data:[],backgroundColor:"rgba(33, 150, 243, 0.7)",borderColor:"rgba(33, 150, 243, 1)",borderWidth:2},{label:"Test MSE",data:[],backgroundColor:"rgba(255, 152, 0, 0.7)",borderColor:"rgba(255, 152, 0, 1)",borderWidth:2}]},options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{display:!1,position:"top"},title:{display:!0,text:"Error by Polynomial Degree"}},scales:{x:{title:{display:!0,text:"Polynomial Degree"}},y:{title:{display:!0,text:"Mean Squared Error"},min:0,max:9e3}}}})}function updateScatterChart(){if(!state.data)return;const trainData=state.data.train_data,testData=state.data.test_data,chart=state.charts.scatter;state.showTest?chart.data.datasets[1].data=testData.x.map((x,i)=>({x:x,y:testData.y[i]})):chart.data.datasets[1].data=[];const coeffs=state.data.fitted_coefficients[state.currentDegree.toString()],xRange=[],minX=Math.min(...trainData.x),maxX=Math.max(...trainData.x);for(let x=minX;x<=maxX;x+=.1)xRange.push(x);const yPred=xRange.map(x=>{let y=0;for(let i=0;i<coeffs.length;i++)y+=coeffs[i]*Math.pow(x,i);return y});chart.data.datasets[2].label=`Degree ${state.currentDegree} Polynomial`,chart.data.datasets[2].data=xRange.map((x,i)=>({x:x,y:yPred[i]})),chart.update("none"),updateMetrics(coeffs);const testMseElement=state.displays.testMse.element;state.showTest?testMseElement.style.display="":testMseElement.style.display="none"}function updateErrorChart(){if(!state.data)return;const errorDecomp=state.data.error_decomposition,trainMSEs=[],testMSEs=[];for(let degree=1;degree<=10;degree++){const data=errorDecomp[degree.toString()];trainMSEs.push(data.train_mse),testMSEs.push(data.test_mse)}state.charts.error.data.datasets[0].data=trainMSEs,state.showTest?state.charts.error.data.datasets[1].data=testMSEs:state.charts.error.data.datasets[1].data=[];const bgColors=new Array(10).fill("rgba(33, 150, 243, 0.7)"),borderColors=new Array(10).fill("rgba(33, 150, 243, 1)");bgColors[state.currentDegree-1]="rgba(33, 150, 243, 1)",borderColors[state.currentDegree-1]="rgba(33, 150, 243, 1)",state.charts.error.data.datasets[0].backgroundColor=bgColors,state.charts.error.data.datasets[0].borderColor=borderColors,state.charts.error.data.datasets[0].borderWidth=bgColors.map((_,i)=>i===state.currentDegree-1?3:2);const bgColorsTest=new Array(10).fill("rgba(255, 152, 0, 0.7)"),borderColorsTest=new Array(10).fill("rgba(255, 152, 0, 1)");bgColorsTest[state.currentDegree-1]="rgba(255, 152, 0, 1)",borderColorsTest[state.currentDegree-1]="rgba(255, 152, 0, 1)",state.charts.error.data.datasets[1].backgroundColor=bgColorsTest,state.charts.error.data.datasets[1].borderColor=borderColorsTest,state.charts.error.data.datasets[1].borderWidth=bgColorsTest.map((_,i)=>i===state.currentDegree-1?3:2),state.charts.error.update()}function updateMetrics(coeffs){const degreeData=state.data.error_decomposition[state.currentDegree.toString()],trainMSE=degreeData.train_mse,testMSE=degreeData.test_mse,equationText=generateEquationText(coeffs),equationEl=document.getElementById("equation");equationEl.innerHTML=equationText,coeffs.length>3?equationEl.classList.add("small-eq"):equationEl.classList.remove("small-eq"),window.MathJax&&(state.displays.trainMse.update(trainMSE,!1),state.displays.testMse.update(testMSE,!1),MathJax.typesetPromise([equationEl,state.displays.trainMse.element,state.displays.testMse.element]).catch(err=>console.log("MathJax error:",err)))}function generateEquationText(coeffs){if(!coeffs)return"$y = 0$";function formatCoeff(coeff){const absCoeff=Math.abs(coeff);if(absCoeff>=1e3||absCoeff<.01&&absCoeff>0){const exp=Math.floor(Math.log10(absCoeff));return`${(absCoeff/Math.pow(10,exp)).toFixed(1)}{\\small \\cdot 10^{${exp}}}`}return absCoeff.toFixed(2)}let terms=[];for(let i=0;i<coeffs.length;i++){const coeff=coeffs[i],value=formatCoeff(coeff),sign=0===i?"":coeff>=0?" + ":" - ";0===i?terms.push(coeff>=0?value:`-${value}`):1===i?terms.push(`${sign}${value}x`):terms.push(`${sign}${value}x^{${i}}`)}if(terms.length>3){const lines=[];for(let i=0;i<terms.length;i+=3){const lineTerms=terms.slice(i,i+3);0===i?lines.push(`y &= ${lineTerms.join("")}`):lines.push(`&\\quad ${lineTerms.join("")}`)}return`$$\\begin{aligned} ${lines.join(" \\\\ ")} \\end{aligned}$$`}return`$y = ${terms.join("")}$`}function setupEventListeners(){new SliderControl("degree-slider",{valueDisplayId:"degree-value",debounceMs:100,onChange:value=>{state.currentDegree=value,updateScatterChart(),updateErrorChart()}});document.getElementById("toggle-test-data").addEventListener("click",e=>{state.showTest=!state.showTest,e.currentTarget.classList.toggle("active"),updateScatterChart(),updateErrorChart()}),document.getElementById("toggle-squared-errors").addEventListener("click",e=>{state.showSquaredErrors=!state.showSquaredErrors,e.currentTarget.classList.toggle("active"),state.charts.scatter.update()})}async function init(){await loadData(),new DemoTabController,state.displays={trainMse:new MetricBoxDisplay("train-mse","MSE",{background:"#e3f2fd",color:"#1976d2",border:"#bbdefb",borderLeft:"#2196f3",label:"Training Set",decimals:1,thousandsSeparator:!0}),testMse:new MetricBoxDisplay("test-mse","MSE",{background:"#fff3e0",color:"#f57c00",border:"#ffe0b2",borderLeft:"#ff9800",label:"Test Set",decimals:1,thousandsSeparator:!0})},state.displays.testMse.element.style.display="none",initCharts(),updateScatterChart(),updateErrorChart(),setupEventListeners()}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",init):init();