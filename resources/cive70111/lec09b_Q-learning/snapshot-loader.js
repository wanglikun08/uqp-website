class SnapshotLoader{constructor(){this.checkpoints={mc:null,sarsa:null,qlearning:null},this.isLoaded=!1,this.isLoading=!1}async loadAllCheckpoints(){if(this.isLoaded)return this.checkpoints;if(this.isLoading){for(;this.isLoading;)await new Promise(resolve=>setTimeout(resolve,100));return this.checkpoints}this.isLoading=!0;try{console.log("Loading checkpoint data for all algorithms...");const[mc,sarsa,qlearning]=await Promise.all([this.loadCheckpointFile("./data/mc_checkpoints.json"),this.loadCheckpointFile("./data/sarsa_checkpoints.json"),this.loadCheckpointFile("./data/qlearn_checkpoints.json")]);return this.checkpoints.mc=mc,this.checkpoints.sarsa=sarsa,this.checkpoints.qlearning=qlearning,this.isLoaded=!0,this.isLoading=!1,console.log("All checkpoints loaded successfully"),this.checkpoints}catch(error){throw this.isLoading=!1,console.error("Failed to load checkpoints:",error),error}}async loadCheckpointFile(path){try{const response=await fetch(path);if(!response.ok)throw new Error(`HTTP ${response.status}: ${response.statusText}`);const data=await response.json();return this.validateCheckpointData(data),data}catch(error){throw console.error(`Failed to load ${path}:`,error),error}}validateCheckpointData(data){if(!data.algorithm)throw new Error("Missing algorithm name");if(!data.metadata||!data.metadata.discretization)throw new Error("Missing discretization metadata");if(!data.checkpoints||0===data.checkpoints.length)throw new Error("No checkpoints found");data.checkpoints.forEach((cp,idx)=>{if(!cp.q_table||!cp.q_table.data||!cp.q_table.shape)throw new Error(`Checkpoint ${idx}: Missing Q-table data`);cp.learning_curve||console.warn(`Checkpoint ${idx}: Missing learning curve`)})}getCheckpoint(algorithm,checkpointIndex){if(!this.isLoaded)throw new Error("Checkpoints not loaded yet. Call loadAllCheckpoints() first.");const algoData=this.checkpoints[algorithm];if(!algoData)throw new Error(`Unknown algorithm: ${algorithm}`);if(checkpointIndex<0||checkpointIndex>=algoData.checkpoints.length)throw new Error(`Invalid checkpoint index: ${checkpointIndex}`);return{...algoData.checkpoints[checkpointIndex],algorithm:algoData.algorithm,discretization:algoData.metadata.discretization,hyperparameters:algoData.metadata.hyperparameters}}getAllCheckpoints(algorithm){if(!this.isLoaded)throw new Error("Checkpoints not loaded yet");const algoData=this.checkpoints[algorithm];if(!algoData)throw new Error(`Unknown algorithm: ${algorithm}`);return algoData.checkpoints.map((cp,idx)=>({...cp,algorithm:algoData.algorithm,discretization:algoData.metadata.discretization,hyperparameters:algoData.metadata.hyperparameters}))}getMetadata(algorithm){if(!this.isLoaded)throw new Error("Checkpoints not loaded yet");const algoData=this.checkpoints[algorithm];if(!algoData)throw new Error(`Unknown algorithm: ${algorithm}`);return algoData.metadata}getCheckpointCount(algorithm){if(!this.isLoaded)return 0;const algoData=this.checkpoints[algorithm];return algoData?algoData.checkpoints.length:0}getCheckpointSteps(algorithm){if(!this.isLoaded)return[];const algoData=this.checkpoints[algorithm];return algoData?algoData.checkpoints.map(cp=>cp.step):[]}static generateMockCheckpoint(algorithm,step,episode){const shape=[5,5,5,5,3],size=shape.reduce((a,b)=>a*b,1),qData=Array(size).fill(0).map(()=>10*Math.random()-5),numEpisodes=Math.max(10,Math.floor(.8*episode)),episodes=Array.from({length:numEpisodes},(_,i)=>i+1),returns=episodes.map(ep=>{const baseReturn=10+40*(ep/numEpisodes),noise=15*(Math.random()-.5);return Math.max(5,baseReturn+noise)}),sampleTransitions=Array(10).fill(0).map(()=>({state:[.1*Math.random()-.05,.1*Math.random()-.05,.1*Math.random()-.05,.1*Math.random()-.05],action:Math.floor(3*Math.random()),reward:1,next_state:[.1*Math.random()-.05,.1*Math.random()-.05,.1*Math.random()-.05,.1*Math.random()-.05],td_error:.5*(Math.random()-.5),q_old:50*Math.random(),q_new:50*Math.random(),q_next_max:50*Math.random()}));return{step:step,episode:episode,q_table:{shape:shape,data:qData},learning_curve:{episodes:episodes,returns:returns},statistics:{avg_return_last_100:returns[returns.length-1]||0,max_return:Math.max(...returns),epsilon:Math.max(.01,1-step/5e4*.99)},sample_transitions:sampleTransitions}}static generateMockData(algorithm){const checkpointEpisodes=[0,125,487,1247];return{algorithm:algorithm,metadata:{environment:"CartPole-v1",total_training_steps:5e4,episodes_trained:1247,discretization:{x_bins:[-2.4,-1.2,0,1.2,2.4],x_dot_bins:[-3,-1,0,1,3],theta_bins:[-.21,-.1,0,.1,.21],theta_dot_bins:[-2,-.5,0,.5,2]},hyperparameters:{gamma:.99,alpha:.1,epsilon_start:1,epsilon_end:.01,epsilon_decay:.995}},checkpoints:[0,2e3,1e4,5e4].map((step,idx)=>this.generateMockCheckpoint(algorithm,step,checkpointEpisodes[idx]))}}}"undefined"!=typeof module&&module.exports&&(module.exports={SnapshotLoader:SnapshotLoader});